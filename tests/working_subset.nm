printf :: extern (fmt: ^char, ...) : int
puts :: extern (s: ^char) : int

allocation_function :: () : [2]{int} @ R
// allocates introduces a new region `R` that the function may allocate in
  with allocates @ R
{
    alloc := [2]{ 1, 2 } @ R

    return alloc
}

return_int :: () : int {
    return 69420
}

main :: () {
    untyped_int := 1
    typed_int : int = 2
    array := [2]{ 1, 2 }
    tuple := (52, true)

    inline_record : { a : int, b : int } = { a := untyped_int, b := typed_int }
    inline_some : Some(int) | None = Some(1)
    inline_none : Some(int) | None = None

    print_int := inline_record.a + inline_record.b

    printf("%d\n", print_int)

    bool_val : bool = false

    if bool_val {
        printf("%d\n", array[0])
    } else {
        printf("%d\n", array[1])
    }

    printf("%d\n", tuple.0)
    if tuple.1 {
        puts("true")
    } else {
        puts("false")
    }

    match inline_some with
        Some(x) => { printf("%d\n", x) }
      | None    => { printf("%d\n", 0) }

    match inline_none with
        Some(x) => { printf("%d\n", x) }
      | None    => { printf("%d\n", 0) }

    match typed_int with
        1 => { printf("%d\n", 1) }
      | 2 => { printf("%d\n", 2) }
      | _ => { printf("%d\n", 999) }

    match 3 with
        1 => { printf("%d\n", 1) }
      | 2 => { printf("%d\n", 2) }
      | _ => { printf("%d\n", 999) }

    region_alloc := [2]{ 3, 4 } @ local

    printf("%d\n", return_int())

    string := "hello world"
    puts(string)


    // dyn_array := [] { 1, 2 }
}
