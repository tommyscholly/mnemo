printf :: extern (fmt: ^char, ...) : int

allocate_comptime :: (comptime T: type, comptime R: region, comptime n: int) : [n]T @ R {
    alloc : [n]T @ R = [n]T{ } @ R

    return alloc
}

identity :: (comptime T: type, x: T) : T {
    return x
}

return_int :: () : int {
    return 69420
}

main :: () { untyped_int := 1
    typed_int : int = 2
    array := [2]int{ 1, 2 }
    tuple := (52, true)

    inline_record : { a : int, b : int } = { a := untyped_int, b := typed_int }
    inline_some : .Some(int) | .None = .Some(1)
    inline_none : .Some(int) | .None = .None

    print_int := inline_record.a + inline_record.b

    printf("%d\n", print_int)

    bool_val : bool = false

    if bool_val {
        printf("%d\n", array[0])
    } else {
        printf("%d\n", array[1])
    }

    printf("%d\n", tuple.0)
    if tuple.1 {
        printf("%s\n", "true")
    } else {
        printf("%s\n", "false")
    }

    match inline_some with
        .Some(x) => { printf("%d\n", x) }
      | .None    => { printf("%d\n", 0) }

    match inline_none with
        .Some(x) => { printf("%d\n", x) }
      | .None    => { printf("%d\n", 0) }

    match typed_int with
        1 => { printf("%d\n", 1) }
      | 2 => { printf("%d\n", 2) }
      | _ => { printf("%d\n", 999) }

    match 3 with
        1 => { printf("%d\n", 1) }
      | 2 => { printf("%d\n", 2) }
      | _ => { printf("%d\n", 999) }

    region_alloc := [2]int{ 3, 4 } @ local

    printf("%d\n", return_int())

    string := "hello world\n"
    printf(string)

    val := identity(int, 1)
    printf("%d\n", val)

    val2 := identity(bool, true)
    printf("%d\n", val2)

    arr_alloc := allocate_comptime(int, local, 2)
    arr_alloc[0] = 100
    arr_alloc[1] = 150

    printf("[%d, %d]\n", arr_alloc[0], arr_alloc[1])
}
