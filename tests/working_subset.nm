printf :: extern (fmt_string: ^char, int_param: int)
print_bool :: extern (bool_param: bool)
print_int :: extern (int_param: int)
make_fmt_str :: extern () : ^char

// allocation_function :: () : [2]{int} @ R
// // allocates introduces a new region `R` that the function may allocate in
//   with allocates @ R
// {
//     alloc := [2]{ 1, 2 } @ R
//
//     return alloc
// }

return_int :: () : int {
    return 69420
}

main :: () {
    untyped_int := 1
    typed_int : int = 2
    array := [2]{ 1, 2 }
    tuple := (52, true)

    inline_record : { a : int, b : int } = { a := untyped_int, b := typed_int }
    inline_some : Some(int) | None = Some(1)
    inline_none : Some(int) | None = None

    print_int := inline_record.a + inline_record.b

    fmt_string := make_fmt_str()
    printf(fmt_string, print_int)

    bool_val : bool = false

    if bool_val {
        printf(fmt_string, array[0])
    } else {
        printf(fmt_string, array[1])
    }

    printf(fmt_string, tuple.0)
    print_bool(tuple.1)

    match inline_some with
        Some(x) => { printf(fmt_string, x) }
      | None    => { printf(fmt_string, 0) }

    match inline_none with
        Some(x) => { printf(fmt_string, x) }
      | None    => { printf(fmt_string, 0) }

    match typed_int with
        1 => { printf(fmt_string, 1) }
      | 2 => { printf(fmt_string, 2) }
      | _ => { printf(fmt_string, 999) }

    match 3 with
        1 => { printf(fmt_string, 1) }
      | 2 => { printf(fmt_string, 2) }
      | _ => { printf(fmt_string, 999) }

    region_alloc := [2]{ 3, 4 } @ local

    print_int(return_int())

    // dyn_array := [] { 1, 2 }
}
