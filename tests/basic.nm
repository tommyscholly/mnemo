T :: { field1: int, field2: int }
Enum :: { X1, X2, X3 }
ADT :: { X1(int), X2(T), X3(Enum) }

foo :: 1

pattern_matching :: (x: ADT) -> int {
    match x {
        X1(y) => y + 1,
        X2(y) => y.field1 + y.field2,
        X3(y) => match y {
            X1 => 1,
            X2 => 2,
            X3 => 3
        }
    }
}

bar :: () -> (fn(int) -> int) @ R 
  with R: region
{
  closure := fn(x: int) = x + 5 @ R
  // this is a heap allocated array of 5 ints
  array := [4]{1, 2, 3, 4} @ R
  // this is stack allocated, because it is not given a region to allocate in
  stack_array := [2]{1, 2}
  // this is a slice, which is dynamically sized
  slice_array := [][1, 2, 3] @ R

  return closure
}
